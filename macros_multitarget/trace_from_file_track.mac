clear_variables();
useRGA = true;
outputTo = "C:\multitarget_data\coords_output_two.sig";
outputCoordinates = true;
//Initialization
bestMaximum = 0;
bestxx = 0;
bestyy = 0;
showSignals = true;//update registers with current signals, if true
stationaryBackground = false;//one signal is used as background
calculateTargetSpace = true;//if false, only signals are acquired/loaded, but no other processing
meanCoef = 0.0;//how much of accumulated background is used in next frame, 0 - means current - prev
backAt = 32;//which frame should be used as a background, when loading from file
startAt = 0;//at which frame to start, when loading from file
endAt = 1000;//at which frame to end, when loading from file
skipSize = 1;//how many points are skipped, while searching for targets in delay-angle space.
//Smaller number means finer search, but longer calculation. Minimum is 1 - each point will be checked

passSize = 4;//if there is gap of lower than threshold values between two regions of higher than threshold values,
//it is ignored and two regions are joined to one target, if gap is less than this parameter

arrayD = 12;//distance between centers of arrays
maxVel = 1.5;//m/s
deltaT = 2;//s expected duration between frames, will be updated

thresholdValue = 200;//checked of power

//Actual RGA parameters
startingStd = 1000;//parameter, large value of standard deviation, if no initialization is present
initFrames = 4;//parameter
foregroundThreshold = 2.5;//parameter, if current value is 2.5 times stdev value or higher, it is foreground
backgroundThreshold = 1;//parameter, if current value is 1 times stdev value or lower, it is foreground
learningRate = 0.5;//parameter, starting learningRate, should reduce as measurement goes
learningRateMult = 0.95;//metaparameter, how much of the learning rate it is left for next measurment
learningRateFloor = 0.05;//metaparameter, lowest possible learning rate value, set to same value like learningRate for constant learning rate
kernelSize = 7;//parameter, how much model values should be smoothed
//end of RGA parameters

//Tracking low level params
maxTracks = 20;
maxData = 40;

numOfTracks = 0;
timestamps = signal(1, maxTracks, false);

//state of tracks
x11 = signal(1, maxTracks, false);
x21 = signal(1, maxTracks, false);
x31 = signal(1, maxTracks, false);
x41 = signal(1, maxTracks, false);

//covariances of tracks
p11 = signal(1, maxTracks, false);
p21 = signal(1, maxTracks, false);
p31 = signal(1, maxTracks, false);
p41 = signal(1, maxTracks, false);

p12 = signal(1, maxTracks, false);
p22 = signal(1, maxTracks, false);
p32 = signal(1, maxTracks, false);
p42 = signal(1, maxTracks, false);

p13 = signal(1, maxTracks, false);
p23 = signal(1, maxTracks, false);
p33 = signal(1, maxTracks, false);
p43 = signal(1, maxTracks, false);

p14 = signal(1, maxTracks, false);
p24 = signal(1, maxTracks, false);
p34 = signal(1, maxTracks, false);
p44 = signal(1, maxTracks, false);

thresholds = signal(1, maxTracks, false);
ages = signal(1, maxTracks, false);
isValidatedArray = signal(1, maxTracks, false);

rData = signal(1, maxData, false);//array of distances
aData = signal(1, maxData, false);//array of angles
isUsedData = signal(1, maxData, false);
isMatchedData = signal(1, maxData, false);
idsData = signal(1, maxData, false);

timestamps = 0;
//end of tracking low level params

//Tracking high level params
trueTrackThreshold = 0.8;
maxVel = 2;//m/s
minVel = 0.1;//m/s
minAgeToDisplayRadial = 3;//track with mostly radial movement needs to be updated for this amount of frames to be displayed
minAgeToDisplayTangental = 6;//track with mostly tangental movement needs to be updated for this amount of frames to be displayed
//end of tracking igh level params


if (useRGA)
{
	thresholdValue = 5;  
}
pulseDuration = 2;//duration for integration, when calculating power from difference
falloffDuration = 0.5;//duration of falloff in integration window, when calculating power from difference
parametersNumber = 6;//when loading, omit first 6 signals, as those are parameters
d = 0.13;//distance between antenna elements
minDistance = rangestart;//rangeStart is given in params.mac
if (minDistance < 0)
{
	  minDistance = 0;
}
distStep = 0.1;
maxDistance = rangeend;

//init of image matrix (where argets are displayed)
imageSizeX = ceil((maxDistance - minDIstance)/distStep);
imageSizeY = ceil((arrayD+18)/distStep);
imageMatrix = matrix(imageSizeX, imageSizeY);
imageMatrix = 0;
//draw(imageMatrix);


c = 0.3;//m/ns
maxTheoreticalDelay = d/c + 0.1;
timeStart = 268 - arrayD/c;//ns, t0
timeStart = 286 - arrayD/c;//ns, t0, this is more apropriate based on results of actual measurements


//if saveTo exists, parameters are read

params1 = sig_read(saveTo,0);
params2 = sig_read(saveTo,1);
params3 = sig_read(saveTo,2);
params4 = sig_read(saveTo,3);
params5 = sig_read(saveTo,4);
params6 = sig_read(saveTo,5);

if (outputCoordinates)
{
	  sig_add(outputTo, params1);
	  sig_delete_all(outputTo);
}

startAngle = params1[0];
endAngle = params2[0];
angleStep = params3[0];
distanceAt0ns = params4[0];//not used
useThirdSignal = params5[0];//not used
coarseDel = params6[0];

maxAngleDisplace = abs(startAngle);
if (abs(maxAngleDisplace) < abs(endAngle))
{
	  maxAngleDisplace = abs(endAngle);
}
	  
numOfSigs = (sig_get_count(saveTo) - parametersNumber);

sigsInPeriod = 8;//how many signals in period of acquisition, if signals were acquired in difference mode from the start
//(16 at once), then taking them by 8 would mean different delays between sets of 8 (due to processing during meas)

numOfSigs = numOfSigs/sigsInPeriod;//how many periods there is
numOfSigs = floor(NumOfSigs);

if (endAt > numOfSigs)
{
	  endAt = numOfSigs;
}

angles = signal(1,numOfSigs,false);
amplitudes = signal(1,numOfSigs,false);

atAngle = startAngle;//deg


prev1 = sig_read(saveTo,parametersNumber);//signal is loaded to get N and T
N = count(prev1);
T = window(prev1);

//scaling registers
r2 = prev1;
r3 = prev1;
r4 = prev1;
r5 = prev1;
r6 = prev1;
r7 = prev1;
r8 = prev1;
r9 = prev1;
r10 = prev1;
r11 = prev1;
r12 = prev1;
r13 = prev1;
r14 = prev1;
r15 = prev1;
r16 = prev1;
r1 = prev1;

powersignal = matrix(8,N);//array to store power, calculated from difference signal
powerRaw = matrix(8,N);//array to store power, calculated from direct signal
powerWithThreshold = matrix(8,N);//if threshold is used for power, here power after applying threshold is stored
prevSignal = matrix(8,N);//previous signal
currentSignal = matrix(8,N);//current signal
differenceSignal = matrix(8,N);//difference between current and previous
angleSpaceStep = 5;//when building angle-delay space, what is angle step
anglesNum = 90/angleSpaceStep+1;//covering 90 degrees field of view with selected step
distanceAngleSpace = matrix(anglesNum,N/skipSize);//building matrix for angle-delay space, it is skipSize times less than number of points
stdevStep = 2*floor(N/skipSize/5/2);//when calculating variable threshold, it is calculated based on standard deviation of
//signal itself around given point, to avoid long calculations, it is calculated in regions, not in every point. So stdevStep is size of region for
//one calculation
thresholdValuesLocal = signal(1, N/skipSize, false);//array, which will be used to store variable (with point in signal) threshold
stddevLocalCalcArray = signal(1, stdevStep, false);//array to store region of power signal for quick mean and stdev calculation

meanValues = matrix(8,N);
stdValuesArr = signal(T,N,false);
stdValuesArr = startingStd;
stdValues = matrix(8,N);
masks = matrix(8,N);

for (k = 0; k < 8; k = k+1)
{
	  set_matrix_row(meanValues, k, sig_read(saveTo,parametersNumber+k));
	  set_matrix_row(stdValues, k, stdValuesArr);
}

kernel = signal(1,kernelSize,false);
kernel = sqrt(2);
extendedKernel = prev1;
extendedKernel = 0;
insert(kernel, 0, kernelSize-1,extendedKernel, 0);

//if maximum angle is wide enough, drawing area width is calculated directly from that angle
//otherwise additional width of maxDistance/3 is added to avoid drawing area as narrow strip
if (maxAngleDisplace > 10)
{
	  maxDisplace = maxDistance*sin(maxAngleDisplace*pi()/180);
}
else
{
	  maxDisplace = maxDistance*sin(maxAngleDisplace*pi()/180) + (maxDistance-minDistance)/3;
}

longDifference = matrix(8,8*N);//8 times increased number of points for difference signal, used for zero padding
longSignal = signal(T,8*N,false);//signal, which has 8 times number of points in same time window, only used to give
//proper frequency scale to longSpectrumConst
longSpectrumConst = fft(longSignal);//long spectrum, used during zeropadding
longSpectrumConst = 0;

sp = fft(prev1);//normal length spectrum, used during zeropadding
divisionStep = (maxDistance + 20 - minDistance)/10;//entire area under test plus 20 meters (to avoid target moving out of the zone)
//devided into 10 to find size of one grid element in drawing

//to avoid strange numbers of division step (for example 2.5824 m), division step is rounded
if ((divisionStep > 0.5) and (divisionStep <= 1.4))
{
	  divisionStep = 1;
}
if ((divisionStep > 1.4) and (divisionStep <= 3))
{
	  divisionStep = 2;
}
if ((divisionStep > 3) and (divisionStep <= 6.5))
{
	  divisionStep = 5;
}
if ((divisionStep > 6.5) and (divisionStep <= 14))
{
	  divisionStep = 10;
}
if ((divisionStep > 14) and (divisionStep <= 50))
{
	  divisionStep = 20;
}

var = ceil((arrayD + 2*maxDisplace)/divisionStep + 2)*divisionStep;//whole visible x
left = ceil(maxDisplace/divisionStep + 1)*divisionStep;//leftmost

out(left, var);

antennasToDisplay = signal(1,12,false);
antennasToDisplay[0] = left;
antennasToDisplay[1] = left;
antennasToDisplay[2] = left;
antennasToDisplay[3] = left;
antennasToDisplay[4] = left;
antennasToDisplay[5] = left;
antennasToDisplay[6] = left;
antennasToDisplay[7] = left;
antennasToDisplay[8] = left + arrayD;
antennasToDisplay[9] = left + arrayD;
antennasToDisplay[10] = left + arrayD;
antennasToDisplay[11] = left + arrayD;
out(maxDisplace);

//xyinit(-maxDisplace*1.2,minDistance,maxDisplace*1.2+arrayD,maxDistance*1.2,antennasToDisplay,divisionStep,1);
xyinit(-left, minDistance-divisionStep, var - left,maxDistance+divisionStep,antennasToDisplay,divisionStep,1);

xyclear();

if (abs(startAngle - endAngle) > 0.01)
{
	  xyaddlines(arrayD,0,arrayD - (maxDistance + 20)*tan(startAngle*pi()/180), maxDistance+20,arrayD,0,arrayD - (maxDistance+20)*tan(endAngle*pi()/180), maxDistance+20);
}

pointsPerNs = N/T;
nsPerPoint = T/N;

slidingWindowN = ceil(pulseDuration*pointsPerNs);
slidingWindow = signal(pulseDuration, slidingWindowN, false);
meanSig = slidingWindow;

signalPart = signal(pulseDuration,slidingWindowN,false);

start1point = 0;
start2point = floor(falloffDuration*slidingWindowN/pulseDuration);
end1point = floor((pulseDuration - falloffDuration)*slidingWindowN/pulseDuration);
end2point = slidingWindowN-1;

slidingWindow = 0;
for (ia = start1point; ia < start2point; ia = ia + 1)
{
	  slidingWindow[ia] = (1 + sin(-pi()/2 + pi() *(ia - start1point)/(start2point - start1point)))/2;
}
for (ia = start2point; ia < end1point; ia = ia + 1)
{
	  slidingWindow[ia] = 1;
}
for (ia = end1point; ia < end2point; ia = ia + 1)
{
	  slidingWindow[ia] = (1 + sin(pi()/2 + pi() *(ia - end1point)/(end2point - end1point)))/2;
}

detected = 0;
sinceDetected = 20;

disp = parametersNumber+0*sigsInPeriod;
prevAngle = 0;
meanSignal = matrix(8,N);

constSignal = prev1;
constSignal = 0;
for (ia = 0; ia < 8; ia = ia + 1)
{
	  set_matrix_row(meanSignal, ia, constSignal);
}


counter = 1;

for (ind1 = 0; ind1 < startAt; ind1 = ind1 + 1)
{
	  test = sig_read(saveTo, disp + ind1*sigsInPeriod);
	  pointCount = count(test);
	  if (pointCount == 3)
	  {
		    disp = disp + 1;
		    coarseDel = test[0];
		    out(coarseDel);
	  }
}
thresholds = signal(1,8,false);
firstOccurance = signal(1,8,false);
lastOccurance = signal(1,8,false);
hadMaximum = signal(1,8,false);

weights = matrix(8,8);
delays = matrix(8,8);
weights = 0;
prevDistance = 0;
prevAngle = 0;


n1=floor(N/20);//10% from start
n2=N-floor(N/20);//90% from start


//windowing function start  
w=prev1;
w=1;//fill with ones


//fill first 10% with rising sinusoid
for(i=0;i<n1;i=i+1)
{
	  w[i]=sqr(sqr(sin(i/n1*pi()/2)));
}

//fill last 10% with rising sinusoid
upper = N - n2;
//index = 0;
for(i=0;i< upper;i=i+1)
{
	  index = n2 + i;
	  w[index]=sqr(sqr(sin(pi()*(upper - i)/(upper)/2)));
}
//windowing function end

targetsUsedDelay = signal(1,300, false);
targetsUsedAngle = signal(1,300, false);
targetsUsedMaximum = signal(1,300, false);
targetsUsedDispersion = signal(1,300, false);
// End of Initialization

xes = signal(1,1000,false);
yes = signal(1,1000,false);
xes = 0;
yes = 0;
currentFrame = 0;
currentTime = 0;//used for tracker


//Main loop
for (ind1 = startAt; ind1 < endAt; ind1 = ind1 + 1)
{
	  numOfData= 0;//num of raw detections for current frame
	  lastIDused = 0;//clobal variable to assigng unique ID for each detection, should be incrementd when detection is added to the list
	  isUsedData = 0;//assigning false to flags of detections data for tracker to use
	  isMatchedData = 0;//assigning false to flags of detections data for tracker to use
	  before = time();
	  //Signal acquisition
	  //print_line("acquiring signal");
	  test = sig_read(saveTo, disp + ind1*sigsInPeriod);
	  pointCount = count(test);
	  if (pointCount == 3)
	  {
		    disp = disp + 1;
		    coarseDel = test[0];
		    out(coarseDel);
	  }
	  curDisp = ind1*sigsInPeriod;
	  for (ka = 0; ka < 8; ka = ka + 1)
	  {
		    set_matrix_row(prevSignal, ka, sig_read(saveTo, disp + ind1*sigsInPeriod + ka));
		    set_matrix_row(currentSignal, ka, sig_read(saveTo, disp + ind1*sigsInPeriod + ka + 8));
	  }
	  
	  
	  loadingTime = time();
	  loadingDuration = loadingTime - before;
	  out(loadingDuration);
	  
	  //print_line("subtracting reference");
	  ffilt1 = 4;//GHz
	  ffilt2 = 4.5;//GHz
	  if (useRGA)
	  {
		    //print_line("");
		    for (ka = 0; ka < 8; ka = ka + 1)
		    { 
			      currentFrame = get_matrix_row(currentSignal, ka) - get_matrix_row(meanValues, ka);
			      set_label(currentFrame,T,"nS","mV");
			      
			      currentFrame = ifft(fft(currentFrame)*fft(extendedKernel));
			      if (ka == 1)
			      {
					r9 = currentFrame;
			      }
			      
			      
			      //removed before currentFrame = lf(currentFrame, ffilt1,ffilt2,-6);
			      currentDeviations = sqrt(get_matrix_row(stdValues, ka));
			      //set_label(currentDeviations,T,"nS","mV");
			      //r14 = currentDeviations;
			      //temp = get_matrix_row(currentSignal, ka);
			      //set_label(temp, T, "ns", "mV");
			      //r15 = temp;
			      //temp = get_matrix_row(meanValues, ka);
			      //set_label(temp, T, "ns", "mV");
			      //r16 = temp;
			      
			      currentMask = currentDeviations;
			      currentMask = 0;
			      for (ia = 0; ia < N; ia = ia + 1)
			      {
					if (abs(currentFrame[ia]) > foregroundThreshold*currentDeviations[ia])
					{
						  currentMask[ia] = 1;
					}
					else
					{
						  if (abs(currentFrame[ia]) > backgroundThreshold*currentDeviations[ia])
						  {
							    currentMask[ia] = (abs(currentFrame[ia]) - backgroundThreshold*currentDeviations[ia])/(foregroundThreshold - backgroundThreshold)/currentDeviations[ia];
						  }
					}
			      }
			      if (ka == 1)
			      {
					r10 = currentDeviations;
			      }

			      currentMask = ifft(fft(currentMask)*fft(extendedKernel));
			      currentDeviations = learningRate*(1-currentMask)*currentFrame*currentFrame + (1 - learningRate*(1-currentMask))*currentDeviations*currentDeviations;
			      //r11 = sqrt(currentDeviations);
			      currentDeviations = ifft(fft(currentDeviations)*fft(extendedKernel));
			      set_matrix_row(meanValues, ka, learningRate*(1-currentMask)*get_matrix_row(currentSignal, ka) + (1 -  learningRate*(1-currentMask))*get_matrix_row(meanValues, ka));
			      //set_matrix_row(meanValues, ka, learningRate*get_matrix_row(currentSignal, ka) + (1 -  learningRate)*get_matrix_row(meanValues, ka));
			      
			      //temp = get_matrix_row(meanValues, ka);
			      //set_label(temp, T, "ns", "mV");
			      //r12 = temp;
			      set_matrix_row(meanSignal, ka, get_matrix_row(meanValues, ka));
			      set_matrix_row(masks, ka, currentMask);
			      //r10 = currentMask;
			      set_matrix_row(stdValues, ka, currentDeviations);
			      //r13 = sqrt(currentDeviations);
			      //pause();
		    }
		    
		    learningRate = learningRate*learningRateMult;
		    if (learningRate < learningRateFloor)
		    {
			      learningRate = learningRateFloor;
		    }
	  }
	  else
	  {
		    if (stationaryBackground)
		    {
			      for (ka = 0; ka < 8; ka = ka + 1)
			      {
					set_matrix_row(prevSignal, ka, w*sig_read(saveTo, parametersNumber + backAt*sigsInPeriod + ka));
			      }
		    }
		    
		    for (ka = 0; ka < 8; ka = ka + 1)
		    {
			      set_matrix_row(meanSignal, ka, (1 - meanCoef)*get_matrix_row(prevSignal,ka) + meanCoef*get_matrix_row(meanSignal,ka));
		    }
	  }

	  //End of Signal acquisition
	  
	  backSubtractionTime = time();
	  backSubtracionDuration = backSubtractionTime - loadingTime;
	  out(backSubtracionDuration);
	  
	  //Difference signal calculation
	 
	  for (point = 0; point < N - slidingWindowN; point = point + 1)
	  {
	    
		    for (ka = 0; ka < 8; ka = ka + 1)
		    {
			      tempNormal = get_matrix_row(currentSignal, ka)/1000;
			      insert(tempNormal,point,point + slidingWindowN - 1, signalPart,0);
			      signalPart = signalPart*slidingWindow;
			      meanVal = mean(signalPart);
			      meanSig = meanVal;
			      set_matrix(powerRaw, ka, point, sum((signalPart - meanSig)*(signalPart - meanSig)));
		    }
	  }
	  
	  for (ka = 0; ka < 8; ka = ka + 1)
	  {
		    if (useRGA)
		    {
			      cur = get_matrix_row(currentSignal,ka);
			      mea = get_matrix_row(meanSignal,ka);
			      
			      set_label(cur,T,"nS","mV");
			      set_label(mea,T,"nS","mV");

			      set_matrix_row(differenceSignal, ka,(cur - mea)*get_matrix_row(masks, ka));
		    }
		    else
		    {
			      cur = get_matrix_row(currentSignal,ka);
			      mea = get_matrix_row(meanSignal,ka);
			      set_label(cur,T,"nS","mV");
			      set_label(mea,T,"nS","mV");
			      curPower = get_matrix_row(powerRaw,ka);
			      set_matrix_row(differenceSignal, ka,lf(cur - mea,ffilt1,ffilt2,-6)/(push(curPower,slidingWindowN/2) + 0.5));
		    }
		    //tempNormal = get_matrix_row(differenceSignal, ka);
		    //set_label(tempNormal,T,"nS","mV");

		    //sp = fft(tempNormal);
		    //longSpectrumConst = 0;
		    //insert(sp,0,N/2-2,longSpectrumConst,0);
		    
		    //set_matrix_row(longDifference, ka, ifft(longSpectrumConst));
	  }
	  //End of Difference signal calculation

	  longDifferenceTime = time();
	  longDifferenceDuration = longDifferenceTime - backSubtractionTime;
	  out(longDifferenceDuration);

	  //Power calculation
	  //print_line("caculating power signals");
	  
	  sigPower = tempNormal;
	  sigPower = 0;
	  for (point = 0; point < N - slidingWindowN; point = point + 1)
	  {
		    for (ka = 0; ka < 8; ka = ka + 1)
		    {
			      tempNormal = get_matrix_row(differenceSignal, ka);

			      insert(tempNormal,point,point + slidingWindowN - 1, signalPart,0);
			      signalPart = signalPart*slidingWindow;
			      meanVal = mean(signalPart);
			      meanSig = meanVal;
			      valueToSet = sum((signalPart - meanSig)*(signalPart - meanSig));
			      if (valueToSet < 0)
			      {
					valueToSet = 0;
			      }
			      set_matrix(powersignal, ka, point, valueToSet);
		    }
	  }
	  //End of Power calculation
	  

	  pos = 0;
	  if (showSignals)
	  {
			  //r1 = get_matrix_row(currentSignal, 0) - get_matrix_row(prevSignal, 0);
			  //r2 = get_matrix_row(currentSignal, 1) - get_matrix_row(prevSignal, 1);
			  //r3 = get_matrix_row(currentSignal, 2) - get_matrix_row(prevSignal, 2);
			  //r4 = get_matrix_row(currentSignal, 3) - get_matrix_row(prevSignal, 3);
			  //r5 = get_matrix_row(currentSignal, 4) - get_matrix_row(prevSignal, 4);
			  //r6 = get_matrix_row(currentSignal, 5) - get_matrix_row(prevSignal, 5);
			  //r7 = get_matrix_row(currentSignal, 6) - get_matrix_row(prevSignal, 6);
			  //r8 = get_matrix_row(currentSignal, 7) - get_matrix_row(prevSignal, 7);
			  
			  temp = get_matrix_row(masks,0);
			  set_label(temp,T,"nS","mV");
			  r1 = temp;
			  temp = get_matrix_row(masks,1);
			  set_label(temp,T,"nS","mV");
			  r2 = temp;
			  temp = get_matrix_row(masks,2);
			  set_label(temp,T,"nS","mV");
			  r3 = temp;
			  temp = get_matrix_row(masks,3);
			  set_label(temp,T,"nS","mV");
			  r4 = temp;
			  temp = get_matrix_row(masks,4);
			  set_label(temp,T,"nS","mV");
			  r5 = temp;
			  temp = get_matrix_row(masks,5);
			  set_label(temp,T,"nS","mV");
			  r6 = temp;
			  temp = get_matrix_row(masks,6);
			  set_label(temp,T,"nS","mV");
			  r7 = temp;
			  temp = get_matrix_row(masks,7);
			  set_label(temp,T,"nS","mV");
			  r8 = temp;
			  
			  temp = get_matrix_row(differenceSignal, 0);
			  set_label(temp,T,"nS","mV");
			  r1 = temp;
			  
			  temp = get_matrix_row(differenceSignal, 1);
			  set_label(temp,T,"nS","mV");
			  r2 = temp;
			  temp = get_matrix_row(differenceSignal, 2);
			  set_label(temp,T,"nS","mV");
			  r3 = temp;
			  temp = get_matrix_row(differenceSignal, 3);
			  set_label(temp,T,"nS","mV");
			  r4 = temp;
			  temp = get_matrix_row(differenceSignal, 4);
			  set_label(temp,T,"nS","mV");
			  r5 = temp;
			  temp = get_matrix_row(differenceSignal, 5);
			  set_label(temp,T,"nS","mV");
			  r6 = temp;
			  temp = get_matrix_row(differenceSignal, 6);
			  set_label(temp,T,"nS","mV");
			  r7 = temp;
			  temp = get_matrix_row(differenceSignal, 7);
			  set_label(temp,T,"nS","mV");
			  r8 = temp;
			  set_matrix_row(meanSignal, ka, get_matrix_row(meanValues, ka));
	  }


	  powerCalcTime = time();
	  powerCalcDuration = powerCalcTime - longDifferenceTime;
	  out(powerCalcDuration);
	  
	  imageMatrix = 0;
	  distanceAngleSpace = 0;
	  targetsFound = 0;

	  if (calculateTargetSpace)
	  {
		    pos = 0;
			      
		    for (ka = 0; ka < 8; ka = ka + 1)
		    {
			      meanVal = mean(get_matrix_row(powersignal,ka));
			      maxVal = max(get_matrix_row(powersignal,ka), pos);
			      thresholds[ka] = (maxVal - meanVal)/2;
			      firstOccurance[ka] = -1;
			      lastOccurance[ka] = -1;
			      hadMaximum[ka] = 0;
		    }

		    //Threshold on power (if needed)
		    currentThreshold = 0;
		    if (currentThreshold > 0)
		    {
			      for (ka = 0; ka < 8; ka = ka + 1)
			      {
					tempNormal = get_matrix_row(powersignal, ka);
					thresholdValueLocal = currentThreshold*max(tempNormal, pos);
					for (ia = 0; ia < N; ia = ia + 1)
					{
						  if (tempNormal[ia]  > thresholdValueLocal)
						  {
							    tempNormal[ia] = tempNormal[ia] - thresholdValueLocal;
						  }
						  else
						  {
							    tempNormal[ia] = 0;
						  }
					}

					set_matrix_row(powerWithThreshold, ka, tempNormal);
			      }
		    }
		    else
		    {
			      for (ka = 0; ka < 8; ka = ka + 1)
			      {
					tempNormal = get_matrix_row(powersignal, ka);
					set_matrix_row(powerWithThreshold, ka, tempNormal);
			      }
		    }
		    //End of Threshold on power (if needed)
		    tempSig = get_matrix_row(powerWithThreshold, 0)/100;
		    set_label(tempSig,T,"nS","mV");
		    //r1 = tempSig;
		    tempSig = get_matrix_row(powerWithThreshold, 1)/100;
		    set_label(tempSig,T,"nS","mV");
		    //r2 = tempSig;
		    tempSig = get_matrix_row(powerWithThreshold, 2)/100;
		    set_label(tempSig,T,"nS","mV");
		    //r3 = tempSig;
		    tempSig = get_matrix_row(powerWithThreshold, 3)/100;
		    set_label(tempSig,T,"nS","mV");
		    //r4 = tempSig;
		    tempSig = get_matrix_row(powerWithThreshold, 4)/100;
		    set_label(tempSig,T,"nS","mV");
		    //r5 = tempSig;
		    tempSig = get_matrix_row(powerWithThreshold, 5)/100;
		    set_label(tempSig,T,"nS","mV");
		    //r6 = tempSig;
		    tempSig = get_matrix_row(powerWithThreshold, 6)/100;
		    set_label(tempSig,T,"nS","mV");
		    //r7 = tempSig;
		    tempSig = get_matrix_row(powerWithThreshold, 7)/100;
		    set_label(tempSig,T,"nS","mV");
		    //r8 = tempSig;
		    
		    //Finding fronts and zero padding
		    for (ka = 0; ka < 8; ka = ka + 1)
		    {
			      tempNormal = get_matrix_row(powerWithThreshold, ka);
					
			      maxValue = max(tempNormal, pos);
			      set_label(tempNormal,T,"nS","mV");
			      tempNormal = differ(tempNormal);//to find steepest front
			      for (la = 0; la < N; la = la + 1)
			      {
					if (tempNormal[la] < 0)
					{
						  tempNormal[la] = 0;
					}
			      }
			      sp = fft(tempNormal);
			      longSpectrumConst = 0;
			      insert(sp,0,N/2-2,longSpectrumConst,0);//zero padding
							      
			      set_matrix_row(longDifference, ka, ifft(longSpectrumConst));	
		    }
		    //Finding fronts and zero padding

		    //r9 = get_matrix_row(longDifference, 0);
		    //r10 = get_matrix_row(longDifference, 1);
		    //r11 = get_matrix_row(longDifference, 2);
		    //r12 = get_matrix_row(longDifference, 3);
		    //r13 = get_matrix_row(longDifference, 4);
		    //r14 = get_matrix_row(longDifference, 5);
		    //r15 = get_matrix_row(longDifference, 6);
		    //r16 = get_matrix_row(longDifference, 7);

		    //thresholdValue = 0.05*max(get_matrix_row(longDifference, 3), pos);
		    //print_line("Signals displayed");
		    
		    
		    //Building delay-angle space
		    //thresholdValue = 1000;
		    
		    //print_line("calculating target space");
		    useNew = true;
		    if (useNew)
		    {
		    for (angle = 0; angle < anglesNum; angle = angle + 1)
		    {
			      delayPerAntenna = d/c*N/T*sin((angle*angleSpaceStep-45)*pi()/180);
			      for (ka = 0; ka < 8; ka = ka + 1)
			      {
					displace = (ka-3)*delayPerAntenna;
					tempNormal = get_matrix_row(powerWithThreshold, ka);
					
					set_label(tempNormal,T,"nS","mV");
					
					tempNormal = differ(tempNormal);//to find steepest front
					
					set_matrix_row(distanceAngleSpace, angle, get_matrix_row(distanceAngleSpace, angle) + push2(tempNormal, displace)/160);
			      }
		    }
		    }
		    useOld = false;
		    if (useOld)
		    {
		    for (distance = 0; distance < N; distance = distance + skipSize)
		    {
			      
			      pointInSignal = distance*8;
			      testSig = get_matrix_row(longDifference, 3);
			      set_label(testSig,T,"nS","mV");

			      thresholdReached = false;
			      for (passInd = 0; passInd < passSize*8; passInd = passInd + 1)
			      {
					tempIndex = pointInSignal + passInd;
					if (tempIndex >= N*8)
					{
						goto can_calc;  
					}
					if (testSig[tempIndex] > thresholdValue)
					{
						  thresholdReached = true;
						  goto can_calc;
					}
			      }
			      
			      can_calc:
			      
			      if (thresholdReached)
			      {
					//print_line("Threshold reached for delay ", distance);
					for (angle = 0; angle < anglesNum; angle = angle + 1)
					{
						  delayPerAntenna = d/c*N/T*8*sin((angle*angleSpaceStep-45)*pi()/180);
						  summation = 0;
						  
						  for (ka = 0; ka < 8; ka = ka + 1)
						  {
							    displace = (ka-3)*delayPerAntenna;
							    index = floor(pointInSignal + displace);
							    if ((index >= 0) and (index < N*8))
							    {
								      tempLong = get_matrix_row(longDifference, ka);
								      summation = summation + tempLong[index]/10;
							    }
						  }
						  //print_line("Summation ", summation);
						  set_matrix(distanceAngleSpace, angle, distance/skipSize, get_matrix(distanceAngleSpace, angle, distance/skipSize) + summation);
					}
			      }

		    }
		    }
		    
		    //End Building delay-angle space
		    
		    buildingDelayAngleTime = time();
		    buildingDelayAngleDuration = buildingDelayAngleTime - powerCalcTime;
		    out(buildingDelayAngleDuration);
		    
		    testArray = get_matrix_row(differenceSignal,0);
		    set_label(testArray,T,"nS","mV");
		    //r9 = testArray;
		    testArray = get_matrix_row(differenceSignal, 1);
		    set_label(testArray,T,"nS","mV");
		    //r10 = testArray;
		    testArray = get_matrix_row(differenceSignal, 2);
		    set_label(testArray,T,"nS","mV");
		    //r11 = testArray;
		    testArray = get_matrix_row(differenceSignal, 3);
		    set_label(testArray,T,"nS","mV");
		    //r12 = testArray;
		    testArray = get_matrix_row(differenceSignal, 4);
		    set_label(testArray,T,"nS","mV");
		    //r13 = testArray;
		    testArray = get_matrix_row(differenceSignal, 5);
		    set_label(testArray,T,"nS","mV");
		    //r14 = testArray;
		    testArray = get_matrix_row(differenceSignal, 6);
		    set_label(testArray,T,"nS","mV");
		    //r15 = testArray;
		    testArray = get_matrix_row(differenceSignal, 7);
		    set_label(testArray,T,"nS","mV");
		    //r16 = testArray;

		    //Building threshold array
		    testArray = get_matrix_row(distanceAngleSpace, (anglesNum-1)/2);
		    set_label(testArray,T,"nS","mV");
		    
		    maximumValue = max(testArray, pos);

		    thresholdValuesLocal = thresholdValue;

		    for (ind11 = 0; ind11 < N/skipSize-stdevStep/2; ind11 = ind11 + 1)
		    {
			      //////print_line("Current index ", ind11);
			      if (ind11 < stdevStep/2)
			      {
					insert(testArray, 0, stdevStep - 1, stddevLocalCalcArray, 0);
					stddevLocalCalcArray = 2*stddevLocalCalcArray*(ind11 + 1)/stdevStep;
			      }
			      else
			      {
					insert(testArray, ind11-stdevStep/2, ind11 + stdevStep/2 - 1, stddevLocalCalcArray, 0);
			      }
			      value = stdev(stddevLocalCalcArray);
			      meanValue = mean(stddevLocalCalcArray);
			      //print_line("st deviation ", value, " mean value ", meanValue);

			      thresholdValuesLocal[ind11] = meanValue + 2*value;
			      if (thresholdValuesLocal[ind11] > 30*thresholdValue)
			      {
					thresholdValuesLocal[ind11] = 30*thresholdValue;
			      }
			      else
			      {
					if (thresholdValuesLocal[ind11] < thresholdValue)
					{
						  thresholdValuesLocal[ind11] = thresholdValue;
					}
			      }
		    }
		    //print_line("Signals displayed");
		    //r15 = thresholdValuesLocal;
		    //thresholdValuesLocal = 1;
		    //End of Building threshold array

		    thresholdValue2 = mean(testArray) + 2*stdev(testArray);
		    
		    //thresholdValue2 = 1;
		    sigForMean = testArray;
		    
		    //Searching for targets and localizing in delay-angle space
		    //print_line("finding targets");
		    someThresholdValue = thresholdValuesLocal[probeIndex];
		    //print_line("thresholdValue2 = ", thresholdValue2);
		    for (ind11 = 0; ind11 < N; ind11 = ind11 + skipSize)
		    {
			      //print_line("ind11", ind11);
			      probeIndex = ind11/skipSize;
			      //if (testArray[probeIndex] > thresholdValuesLocal[probeIndex])
			      if (testArray[probeIndex] > thresholdValue2)
			      {
					for (ind2 = ind11 + skipSize; ind2 < N; ind2 = ind2 + skipSize)
					{
						  probeIndex2 = ind2/skipSize;
						  //if (testArray[probeIndex2] < thresholdValuesLocal[probeIndex2])
						  if (testArray[probeIndex2] < thresholdValue2)
						  {
							    if (ind2 >= ind11 + 3*skipSize)//wide enough
							    {
								      //print_line("New meaurement from index ", probeIndex, " to index ", probeIndex2);
								      //calculation of center of mass
								      totalWeight = 0;
								      totalDist = 0;
								      totalAngle = 0;
								      totalDisp = 0;
								      totalDispWeight = 0;
								      absoluteMax = 0;
								      meanVal = 0;
								      
								      for (angle = 0; angle < anglesNum; angle = angle + 1)
								      {
										tempSig = get_matrix_row(distanceAngleSpace, angle)/thresholdValue2;
										//r15 = tempSig;
										sigForMean = 0;
										insert(tempSig, ind11/skipSize, ind2/skipSize, sigForMean, 0);
										meanVal = meanVal + mean(sigForMean);
										localMax = max(sigForMean, pos);
										if (localMax > absoluteMax)
										{
											  absoluteMax = localMax;
										}
								      }
								      meanVal = meanVal/anglesNum;
								      
								      for (angle = 0; angle < anglesNum; angle = angle + 1)
								      {
										tempSig = get_matrix_row(distanceAngleSpace, angle)/thresholdValue2;
										
										for (ind3 = ind11; ind3 <= ind2; ind3 = ind3+skipSize)
										{
											  probeIndex3 = ind3/skipSize;
											  totalDisp = totalDisp + 100*(meanVal - tempSig[probeIndex3])*(meanVal - tempSig[probeIndex3]);
											  //totalDispWeight = totalDispWeight +tempSig[ind3/skipSize];
											  totalDispWeight = totalDispWeight + 1;
											  if(tempSig[probeIndex3] > 0.7*absoluteMax)
											  { 
												   totalDist = totalDist + ind3*(tempSig[probeIndex3] - 0.7*absoluteMax);
												    totalAngle = totalAngle + angle*(tempSig[probeIndex3] - 0.7*absoluteMax);
												    totalWeight = totalWeight+(tempSig[probeIndex3] - 0.7*absoluteMax);
												    
											  }
										}
								      }
								      
								      width = ind2 - ind11;
								      targetsUsedDelay[targetsFound] = totalDist/totalWeight;
								      targetsUsedAngle[targetsFound] = totalAngle/totalWeight*angleSpaceStep-50;
								      targetsUsedMaximum[targetsFound] = absoluteMax;
								      targetsUsedDispersion[targetsFound] = totalDisp/anglesNum*skipSize/(ind2 - ind11 + 1);
								      //print_line("Absolute maximum ", absoluteMax);
								      //tempDisp = targetsUsedDispersion[targetsFound];
								      //print_line("Dispersion ", tempDisp);
								      if (targetsUsedDispersion[targetsFound] > 20*targetsUsedMaximum[targetsFound])
								      {
										//only increase target count, if it is not some near constant blob
										targetsFound = targetsFound + 1;
								      }
								      else
								      {
	
										localDisp = totalDisp/totalDispWeight/anglesNum*skipSize/(ind2 - ind11 + 1);
								      }
								      ind11 = ind2 + skipSize;
								      goto ne;
							    }
							    else
							    {
								    ind11 = ind2 + skipSize;
								      goto ne;  
							    }
						  }
					}
			      }
			      
			      ne:
		    }
		    
		    //End of Searching for targets and localizing in delay-angle space
		    //print_line("passing detections to tracking arrays");
		    bestMaximum = 0;
		    bestxx = 0;
		    bestyy = 0;
		    coordinatesArray = signal(1,64,false);
		    coordinatesArray = -100;
		    for (ia = 0; ia < targetsFound; ia = ia + 1)
		    {
			      curDelay = targetsUsedDelay[ia];
			      curAngle = targetsUsedAngle[ia];
			      curMax = targetsUsedMaximum[ia];
			      curDispersion = targetsUsedDispersion[ia];
			      
			      if (curDispersion > 1000)
			      {
					curDispersion = 1000;
			      }
			      
			      //calculation of coordinates from angle and total path from transmitter to target to receiver
			      //let C be base of radar (arrayD)
			      //let A be distance from receiving array to target
			      //let B be distance from transmitting array to target
			      //let alpha be angle between A and C
			      //total path r is known, also:
			      //r = A + B;
			      //from theorem of cosine:
			      //B^2 = A^2 + C^2 - 2ACcos(alpha)
			      //B = r - A;
			      //r^2 - 2rA + A^2 = A^2 + C^2 - 2ACcos(alpha)
			      //2A(Ccos(alpha) - r)= C^2 - r^2;
			      //A = (C^2-r^2)/(2(Ccos(alpha) - r));
			      
			      r = (curDelay*T/N + coarseDel - timeStart)*c;
			      AA = (arrayD*arrayD - r*r)/(2*(arrayD*cos((90-curAngle)*pi()/180) - r));
			      x = AA*cos((90-curAngle)*pi()/180);
			      y = AA*sin((90-curAngle)*pi()/180);
			      
			      //data for tracking
			      
			      rData[numOfData] = AA;
			      aData[numOfData] = curAngle;
			      idsData[numOfData] = lastIDused;
			      print_line("Adding new measurement x=", x, ", y=", y);
			      
			      lastIDused = lastIDused + 1;
			      if (numOfData + 1 < maxData)
			      {
					numOfData= numOfData + 1;
			      }
			      
			      //data for tracking is updated
			      
			      
			      ////print_line("Coordinates are: x ", x, ", y ", y);
			      xindex = ia*2;
			      yindex = ia*2+1;
			      coordinatesArray[xindex] = r;
			      coordinatesArray[yindex] = curAngle;
			      
			      //if (curMax*curDispersion > bestMaximum)
			      if (curDispersion > bestMaximum)
			      {
					//bestMaximum = curMax*curDispersion;
					bestMaximum = curDispersion;
					bestxx = x;
					bestyy = y;
			      }

			      //xyplot(x-arrayD/2,y);
			      xIndex = imageSizeX - floor((y-minDistance)/(maxDistance - minDistance)*imageSizeX);//yes, it is stored to x
			      yIndex = floor((x+9)/(arrayD+18)*imageSizeY);
			      
			      effectiveSize = floor(4000/curDispersion + 1)*0.1/distStep;//limit of maximum size of target, to save processing time
			      if (effectiveSize > imageSizeX/2)
			      {
					effectiveSize = floor(imageSizeX/2);
			      }
			      //print_line("Effective size of target ", ia, " is ", effectiveSize);

			      //filling image matrix region with target
			      //for (xInd = -effectiveSize; xInd < effectiveSize; xInd = xInd + 1)
			      //{
					//for (yInd = -effectiveSize; yInd < effectiveSize; yInd = yInd + 1)
					//{
						  //if ((xIndex+xInd >= 0) and (xIndex+xInd < imageSizeX) and (yIndex+yInd >= 0) and (yIndex+yInd < imageSizeY))
						  //{
							     //if (get_matrix(imageMatrix, xIndex+xInd, yIndex+yInd) < (exp(-(xInd*xInd + yInd*yInd)*((curDispersion + 30)/10000)))*curMax)
							    //{
								      //set_matrix(imageMatrix, xIndex+xInd, yIndex+yInd, (exp(-(xInd*xInd + yInd*yInd)*((curDispersion + 30)/10000)))*curMax);
							    //} 
						  //}
					//}
			      //}
			      
			      
			      
			      
		    }
		    
		    //tracking performed, numOfTracks and relevant signals are updated
		    //print_line("performing tracking");
		    () = tracking_process(timestamps, x11, x21, x31, x41, p11, p21, p31, p41, p12, p22, p32, p42, p13, p23, p33, p43, p14, p24, p34, p44, thresholds, ages, numOfTracks, maxTracks, rData, aData, isUsedData, isMatchedData, idsData, numOfData, currentTime);
		    print_line("Number of tracks after update ", numOfTracks);
		    
		    //here tracks are validated and can be displayed, if valid
		    displayTrackIndex = 0;
		    for (tr = 0; tr < 20; tr = tr + 1)
		    {
			      xyplot(tr, -2000, -2000);
		    }
		    for (tr = 0; tr < numOfTracks; tr = tr + 1)
		    {
			      print_line("Track ", x11[tr], " ", x31[tr]);
			    //currentTrack = currentTracks(tr);
			  
			    //currentThresholdRatio = currentTrack.threshold/trueTrackThreshold
			      if (thresholds[tr]/ages[tr] > trueTrackThreshold)
			      {
					print_line("Track didn't pass by precision ", thresholds[tr]);
					//ageParam = currentTrack.threshold/currentTrack.age
					goto endofloop;
			      }


			      //r = state(1);
			      //dr = state(2);
			      //dTh = state(5)*pi/180;//1 degree
			      //angle = state(4)*pi/180;

			      angle = x31[tr]*pi()/180;
			      x = x11[tr]*sin(angle);
			      y = x11[tr]*cos(angle);
			      dTh = x41[tr]*pi()/180;

			      vx = x21[tr]*sin(angle) + x11[tr]*dTh*cos(angle);
			      vy = x21[tr]*cos(angle) - x11[tr]*dTh*sin(angle);

			      vel = sqrt(vx*vx + vy*vy);


			      if (vel < minVel)
			      {
					goto endofloop;
			      }

			      if (vel > maxVel)
			      {
					goto endofloop;
			      }

			      if (ages[tr] < minAgeToDisplayRadial)
			      {
					goto endofloop;
			      }
			  
			  
			      //tangental only movement can be easily faked by several stationary reflections, so should be registered after more updates
			      if (abs(x21[tr]) < 0.5*x11[tr]*tan(x31[tr]*pi()/180))//tangental movement is twice faster than radial
			      {
					if (ages[tr] < minAgeToDisplayTangental)
					{
						  goto endofloop;
					}
			      }
			      print_line("Have valid track ", x, " ", y);
			      
			      xyplot(displayTrackIndex, x , y);
			      
			      //Showing detections as matrixbelow
			      //filling image matrix region with target
			      
			      //xIndex = imageSizeX - floor((y-minDistance)/(maxDistance - minDistance)*imageSizeX);//yes, it is stored to x
			      //yIndex = floor((x+9)/(arrayD+18)*imageSizeY);

			      //effectiveSize = 10;//limit of maximum size of target, to save processing time
			      //for (xInd = -effectiveSize; xInd < effectiveSize; xInd = xInd + 1)
			      //{
					//for (yInd = -effectiveSize; yInd < effectiveSize; yInd = yInd + 1)
					//{
						  //if ((xIndex+xInd >= 0) and (xIndex+xInd < imageSizeX) and (yIndex+yInd >= 0) and (yIndex+yInd < imageSizeY))
						  //{
							    //set_matrix(imageMatrix, xIndex+xInd, yIndex+yInd, exp(-(xInd*xInd + yInd*yInd)/100));
						  //}
					//}
			      //}
			      //end of showing detections
			      displayTrackIndex = displayTrackIndex + 1;
			      
			      
			      endofloop:
			      //print_line("end of loop");
		    }
		    print_line("");
		    print_line("");
		    //end of tracking code
		    
		    if (outputCoordinates)
		    {
			      sig_add(outputTo, coordinatesArray);
		    }
		    
		    xes[currentFrame] = bestxx;
		    yes[currentFrame] = bestyy;

		    currentFrame = currentFrame + 1;
		    set_matrix(imageMatrix,0,0,3);
		    continue2:

	  }
		    
	  //draw(distanceAngleSpace);
	  //draw(imageMatrix);

	  
	  leftProcessing = time()-buildingDelayAngleTime;
	  out(leftProcessing);
	  
	  totalProcessing = time() - before;
	  out(totalProcessing);
	  
	  //pause();
	  
	  next:
	  currentTime = currentTime + 2;//approx two seconds for complete cycle is expected
	  //currentTime = currentTime + totalProcessing;//this should be used for real time eastimation
}

r15 = xes;
r16 = yes;

//End of Main loop
